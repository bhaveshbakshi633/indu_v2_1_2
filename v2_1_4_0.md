# V2.1.4.0 (v2.9) - Safety Critical Fixes

## Release Date: 2026-01-15

---

## **Docker Version: v2.12**

---

## CRITICAL FIXES

### FIX #1: ARM SNAP on FSM Re-entry [CRITICAL]
**Previous Behavior:**
- When FSM left 801, commanded_pos_ was NOT cleared
- When FSM returned to 801, arm snapped to old stale position

**New Behavior:**
- New ARM_DISABLING state ramps Kp to 0 over 500ms
- commanded_pos_ explicitly cleared on disable
- ARM_DISABLED state requires explicit init_arms to re-enable

### FIX #2: stop() No Longer Clears Safety Faults [CRITICAL]
**Previous Behavior:**
- `stop()` command set `safety_ok_ = true`
- Any safety fault could be bypassed by calling stop

**New Behavior:**
- `stop()` only syncs position, does NOT clear safety
- New `reset_safety` command with explicit checks:
  - Verifies FSM == 801
  - Verifies lowstate is fresh
  - Syncs commanded_pos_ before clearing

### FIX #3: FSM Polling Increased to 50Hz [HIGH]
**Previous:** 5Hz (200ms interval) - 100 commands sent before FSM change detected
**New:** 50Hz (20ms interval) - max 10 commands before detection

### FIX #4: FSM State Broadcast from Orchestrator [HIGH]
**New Feature:**
- Orchestrator publishes to /fsm_state topic BEFORE changing robot FSM
- Arm controller receives immediate notification
- 600ms delay before actual FSM change - gives arm_controller time to disable

### FIX #5: Command Authority FSM Check [HIGH]
**New Feature:**
- Commands rejected at reception if FSM != 801
- Commands rejected if arm_state == ARM_DISABLED (except init_arms)
- Prevents any command execution during unsafe states

### FIX #6: trajectory_ Data Race [HIGH]
**Previous:** trajectory_ vector accessed from multiple threads without protection
**New:** std::mutex trajectory_mutex_ protects all accesses

### FIX #7: Status Format Changed to JSON [MEDIUM]
**Previous:** "state:HOLDING,safety:OK,..."
**New:** {"arm_state":"HOLDING","safety":"OK",...}
- Compatible with status_announcer.py JSON parser

---

## NEW COMMANDS

| Command | Description |
|---------|-------------|
| `reset_safety` | Explicitly clear safety fault (with checks) |
| `disable_arms` | Manually trigger arm disable |

---

## NEW ARM STATES

| State | Description |
|-------|-------------|
| ARM_DISABLED | Zero torque, no commands, waiting for init_arms |
| ARM_DISABLING | Ramping Kp to 0, clearing commanded_pos_ |
| ARM_ENABLING | Ramping Kp up (used during init_arms) |

---

## CHANGED CONSTANTS

| Constant | Old | New | Reason |
|----------|-----|-----|--------|
| MAX_POSITION_ERROR | 0.3 rad | 0.1 rad | 17° too large, now 5.7° |
| FSM_POLL_INTERVAL_MS | 200 | 20 | Faster FSM detection |
| DISABLE_RAMP_DURATION | N/A | 0.5s | Safe arm disable |
| ENABLE_RAMP_DURATION | N/A | 2.0s | Safe arm enable |

---

## TESTING CHECKLIST

- [ ] Start system, init robot (FSM 801)
- [ ] Run init_arms - verify arms hold position
- [ ] Send damp command - verify arms ramp down smoothly (no snap)
- [ ] Return to FSM 801 - verify arms stay disabled
- [ ] Run init_arms again - verify arms re-enable smoothly
- [ ] Trigger safety fault - verify stop() does NOT clear it
- [ ] Use reset_safety - verify it clears with proper checks

---

## FILES MODIFIED

1. `arm_controller.hpp` - New states, constants, mutex
2. `arm_controller_node.cpp` - All safety fixes
3. `g1_orchestrator_node.cpp` - FSM broadcast, fixed detached threads
